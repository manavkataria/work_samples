#!/usr/bin/env python

import pandas as pd
import utils


def isValidReference(token):
    if len(token) == 2 and token[0].isalpha() and token[1].isnumeric():
        return True
    else:
        return False


def extract_token_reference(spreadsheet_df, cell):
    substituted_tokens = []
    for token in cell.split():
        if isValidReference(token):
            # Extract token references
            col_ref = token[0]
            row_ref = int(token[1])  # Reference rows start from 1
            ref_cell = spreadsheet_df[col_ref][row_ref]
            # NOTE: Recurssively evaluating the substituted cell
            token = extract_token_reference(spreadsheet_df, ref_cell)
        else:
            pass # do nothing
        substituted_tokens.append(token)
    # Return cell with tokens references substituted
    return ' '.join(substituted_tokens)


class PostfixParser(object):
    """
        PostfixParser class.

        NOTE: This class abstracts the input _format_ specific parsing. Input format is likely
        to change with time. Ideally, there should be dedicated classes for each input source
        isolating format specific parsing functionality.

        Idempotent Interfaces:
            PostfixParser(): Constructor that loads & parses input spreadsheet
            parser.evaluate(): Evaluate: Postfix Expressions

        Non-Idempotent Interfaces:
            generate_report(): Report: Produce Output Spreadsheet
    """

    def __init__(self, input_csv_path):
        """
            Construtor for `PostfixParser`.

            Performs the following steps:
            #     1. Loads facilities, covenants and loans csv into dataframes.
            #     2. Parses facilities and covenants into a unified list of `Facility` objects.
            #     3. Sorts `facilities_list` by `interest_rate` to optimize yield
            #
            # Arguments:
            #     input_csv_path (string)
            #     covenants_csv_path (string)
            #     loans_csv_path (string)
            #
            # Returns:
            #     `PostfixParser` object
            #
            # Raises:
            #     OSError: if any of the input files are not accessible
        """

        # Load Spreadsheet
        column_names = ['a', 'b', 'c', 'd']  # TODO(Future): Ideally this should be autogenerated
        self.spreadsheet_df = pd.read_csv(input_csv_path, names=column_names, index_col=False)

        # Shift down rows to start rows numbers by 1
        self.spreadsheet_df.loc[len(self.spreadsheet_df)] = ''
        self.spreadsheet_df = self.spreadsheet_df.shift().dropna()

        self.substitute_cells()

    def substitute_cells(self):
        """
            substitute_cells

            Assuming:
                1. No recurssive references
                2. No double indirection
        """

        for row in range(1, len(self.spreadsheet_df) + 1):
            for col in self.spreadsheet_df.columns:
                cell = self.spreadsheet_df[col][row]

                print(col+str(row)+':', cell.split())
                result = extract_token_reference(self.spreadsheet_df, cell)
                self.spreadsheet_df[col][row] = result

                cell = self.spreadsheet_df[col][row]
                print(col+str(row)+'>', cell.split())

        import ipdb; ipdb.set_trace()


    def evaluate(self):
        """
            Evaluate each of the cells in spreadsheet_df while substituting corresponding cells
        """
        pass

    def generate_report(self, output_csv):
        """

        """
        pass
