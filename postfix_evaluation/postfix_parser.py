#!/usr/bin/env python

import pandas as pd
import utils

class PostfixParser(object):
    """
        PostfixParser class.

        NOTE: This class abstracts the input _format_ specific parsing. Input format is likely
        to change with time. Ideally, there should be dedicated classes for each input source
        isolating format specific parsing functionality.

        Interfaces:
            PostfixParser(): Constructor that loads & parses input spreadsheet
            parser.evaluate(): Evaluate: Postfix Expressions
            generate_report(): Report: Produce Output Spreadsheet
    """

    def __init__(self, input_csv_path):
        """
            Construtor for `PostfixParser`. Loads, cleans, and dereferences spreadsheet
            thus making it ready for postfix evaluation.

            Performs the following steps:
                1. Loads spreadsheet into a dataframe.
                2. Fills missing cells with default '0'
                3. Substitutes cell reference pointers with corresponding value

            Arguments:
                input_csv_path (string)

            Returns:
                `PostfixParser` object

            Raises:
                OSError: if any of the input file is not accessible

            Side Effects:
                Writes self.spreadsheet_df
        """

        # Load Spreadsheet
        column_names = ['a', 'b', 'c', 'd']  # TODO(Future): Ideally this should be autogenerated
        self.spreadsheet_df = pd.read_csv(input_csv_path, names=column_names, index_col=False)

        # Shift down rows to start rows numbers by 1
        self.spreadsheet_df.loc[len(self.spreadsheet_df)] = ''
        self.spreadsheet_df[self.spreadsheet_df == ' '] = '0'   # NOTE: Substituting default '0' for empty cells
        self.spreadsheet_df = self.spreadsheet_df.shift().dropna()

        self.substitute_cells()

    def substitute_cells(self):
        """
            Resursively substitute cell reference pointers with corresponding values

            Arguments:
                None

            Returns:
                None

            Raises:
                None

            Side Effects:
                Writes self.spreadsheet_df
        """

        for row in range(1, len(self.spreadsheet_df) + 1):
            for col in self.spreadsheet_df.columns:
                cell = self.spreadsheet_df[col][row]
                self.spreadsheet_df[col][row] = utils.extract_token_reference(self.spreadsheet_df, cell)


    def evaluate(self):
        """
            Evaluate each of the cells in spreadsheet_df using a stack

            Arguments:
                None

            Returns:
                None

            Raises:
                None

            Side Effects:
                Writes self.spreadsheet_df

            TODO(Future):
                Raise:
                  InvalidToken
                  InvalidExpression
        """
        for row in range(1, len(self.spreadsheet_df) + 1):
            for col in self.spreadsheet_df.columns:
                cell = self.spreadsheet_df[col][row]
                stack = list()
                try:
                    for token in cell.split():
                        if token.isnumeric():
                            stack.append(token)
                        elif token in '+-/*':
                            operand1 = stack.pop()
                            operand2 = stack.pop()
                            result = str(eval(operand2 + token + operand1))
                            stack.append(result)
                        else:
                            # raise 'InvalidToken'  # TODO(Future)
                            pass

                    if len(stack) == 1:
                        self.spreadsheet_df[col][row] = stack.pop()
                    else:
                        self.spreadsheet_df[col][row] = '#ERR'
                        # raise 'InvalidExpression' # TODO(Future)
                except:
                    self.spreadsheet_df[col][row] = '#ERR'
                    # raise 'InvalidExpression'  # TODO(Future)

    def generate_report(self, csv_filepath):
        """
            Generates an overall yield report of all facilities

            NOTE: This is not an idempotent fuction as it issues side effects

            Arguments:
                csv_filepath (string)

            Returns:
                None

            Raises:
                OSError: if csv_filepath is not accessible

            Side Effects:
                Writing to a file
        """
        self.spreadsheet_df.to_csv(path_or_buf=csv_filepath, index=False, header=None)
